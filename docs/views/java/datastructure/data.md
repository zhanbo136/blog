---
title: 数据结构详解
date: 2020-05-10
tags:
 - 数据结构
categories: 
 - 编程基础
---
# 数据结构

**数据结构的分类**

- 线性（数组、链表、栈、队列）
  - 顺序存储（在内存中的地址是连续的）
    - 数组
  - 链式存储（在内存中的地址不一定是连续的）
    - 链表
- 非线性
  - 二维数组
  - 多维数组
  - 广义表
  - 树结构
  - 图结构

## 稀疏数组

> **基本介绍**

当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。
稀疏数组的处理方法是: 

- 1) 记录数组一共有几行几列，有多少个不同的值 
- 2) 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

![image-20200516153315323](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200516153324.png)

> **应用实例** 

- 1) 使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等) 
- 2) 把稀疏数组存盘，并且可以从新恢复原来的二维数组数 
- 3) 整体思路分析

![image-20200516153336399](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200516153338.png)

## 队列

> **基本介绍**

- 1) 队列是一个有序列表，可以用数组或是链表来实现。 

- 2) 遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出 

- 3) 示意图：(使用数组模拟队列示意图)

  ![image-20200516192051933](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200516192053.png)



数组模拟队列思路

- 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队
  列的最大容量。 

- 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标， front 会随着数据输出而改变，而 rear 则是随着数据输入而改变，如图所示:

  ![image-20200516192204642](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200516192205.png)

- 当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：思路分析 

  - 1) 将尾指针往后移：rear+1, 当 front ==rear 【空】 
  - 2) 若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear 所指的数组元素中，否则无法存入数据。 rear ==maxSize-1[队列满] 

> **问题分析并优化** 

- 1) 目前数组使用一次就不能用， 没有达到复用的效果 
- 2) 将这个数组使用算法，改进成一个环形的队列 取模：%

> **数组模拟环形队列**

对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可)
分析说明： 

- 1) 尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的 时候需要注意 (rear+1)%maxSize==front 满] 

- 2) rear==front[空] 

- 3) 分析示意图:

  ![image-20200516192311530](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200516192312.png)



## 链表

> **基本介绍**

链表是有序的列表，但是它在内存中是存储如下

![image-20200517114833085](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200517114841.png)

**小结上图:** 

- 1) 链表是以节点的方式来存储,是链式存储 
- 2) 每个节点包含 data 域， next 域：指向下一个节点. 
- 3) 如图：发现链表的各个节点不一定是连续存储. 
- 4) 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定  单链表(带头结点) 逻辑结构示意图如下

![image-20200517114912877](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200517114913.png)



> **单链表的应用实例** 

使用带 head 头的单向链表实现 –水浒英雄排行榜管理完成对英雄人物的增删改查操作。

- 1) 第一种方法在添加英雄时，直接添加到链表的尾部 思路分析示意图:![image-20200517114949618](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200517114951.png)

- 2) 第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示) 思路的分析示意图:

![image-20200517115017474](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200517115019.png)

- 3) 修改节点功能 思路

  - (1) 先找到该节点，通过遍历，
  - (2)temp.name=newHeroNode.name;temp.nickname=newHeroNode.nickname 

- 4) 删除节点 思路分析的示意图

  ![image-20200517115202694](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200517115203.png)

> **双向链表应用实例** 

使用带 head 头的双向链表实现 –水浒英雄排行榜  

**管理单向链表的缺点分析:** 

- 1) 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。 
- 2) 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除 时节点，总是找到 temp,temp 是待删除节点的前一个节点(认真体会). 
- 3) 分析了双向链表如何完成遍历，添加，修改和删除的思路

对上图的说明: 分析 双向链表的遍历，添加，修改，删除的操作思路===》代码实现 

- 1) 遍历 方和 单链表一样，只是可以向前，也可以向后查找 
- 2) 添加 (默认添加到双向链表的最后)
  -  (1) 先找到双向链表的最后这个节点 
  -  (2)temp.next=newHeroNode (3)newHeroNode.pre=temp; 
- 3) 修改 思路和 原来的单向链表一样. 
- 4) 删除 
  - (1) 因为是双向链表，因此，我们可以实现自我删除某个节点 
  - (2) 直接找到要删除的这个节点，比如 temp 
  - (3) temp.pre.next=temp.next 
  - (4)temp.next.pre=temp.pre; 

> **单向环形链表应用场景** 

Josephu(约瑟夫、约瑟夫环) 问题 Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1<=k<=n）的人从 1 开始报数，数 到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。

提示：用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结 点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直
到最后一个结点从链表中删除算法结束。

> **单向环形链表介绍**

![image-20200517221116537](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200517221118.png)

> **Josephu 问题**

**约瑟夫问题的示意图**	

![image-20200517221135082](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200517221136.png)

>  **Josephu 问题** 

Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1<=k<=n）的人从 1 开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此
产生一个出队编号的序列。

> **提示** 

用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开 始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。

 约瑟夫问题-创建环形链表的思路图解

![image-20200517221224861](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200517221243.png)

约瑟夫问题-小孩出圈的思路分析图	

![image-20200517221240967](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200517221246.png)

## 栈

> **栈的介绍**

- 1) 栈的英文为(stack) 
- 2) 栈是一个先入后出(FILO-FirstInLastOut)的有序列表。
- 3) 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的 一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。 
- 4) 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元
  素最先删除，最先放入的元素最后删除 
- 5) 图解方式说明出栈(pop)和入栈(push)的概念

![image-20200518112724172](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200518112732.png)

> **栈的应用场景** 

- 1) 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以
  回到原来的程序中。
- 2) 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆
  栈中。 
- 3) 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。 
- 4) 二叉树的遍历。 
- 5) 图形的深度优先(depth 一 first)搜索法。

**栈的快速入门** 

- 1) 用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容，
  下面我们就用数组模拟栈的出栈，入栈等操作。 
- 2) 实现思路分析,并画出示意图

![image-20200518112750386](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200518112751.png)

> **栈实现综合计算器(中缀表达式)** 

![image-20200518154907204](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200518154908.png)

 **思路分析(图解)**

![image-20200518154925927](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200518154927.png)

> **逆波兰计算器** 

- 1) 输入一个逆波兰表达式(后缀表达式)，使用栈(Stack), 计算其结果 
- 2) 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。 
- 3) 思路分析 

```
例如:(3+4)×5-6 对应的后缀表达式就是 34+5 × 6-, 针对后缀表达式求值步骤如下:
1．从左至右扫描，将 3 和 4 压入堆栈； 
2．遇到+运算符，因此弹出 4 和 3（4 为栈顶元素，
3 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈； 3．将 5 入栈； 
4．接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈； 
5．将 6 入栈； 
6．最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果
```

**中缀表达式转换为后缀表达式**

大家看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发
中，我们需要将 中缀表达式转成后缀表达式。

> **具体步骤**

- 1) 初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2； 
- 2) 从左至右扫描中缀表达式； 
- 3) 遇到操作数时，将其压 s2； 
- 4) 遇到运算符时，比较其与 s1 栈顶运算符的优先级： 
  - 1.如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈； 
  - 2.否则，若优先级比栈顶运算符的高，也将运算符压入 s1； 
  - 3.否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(4-1)与 s1 中新的栈顶运算符相比较； 
- 5) 遇到括号时： 
  - 1 如果是左括号“(”，则直接压入 s1 
  - 2 如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃 
- 6) 重复步骤 2 至 5，直到表达式的最右边 
- 7) 将 s1 中剩余的运算符依次弹出并压入 s2 
- 8) 依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式

> **举例说明:** 

将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下
因此结果为 :"123+4 × +5 –"

![image-20200518155225080](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200518155226.png)

> **代码实现中缀表达式转为后缀表达式**

**思路分析**

![image-20200518155310849](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200518155312.png)

## 哈希表

> **哈希表的基本介绍** 

散列表（Hashtable，也叫哈希表），是根据关键码值(Keyvalue)而直接进行访问的数据结构。也就是说，它通
过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组
叫做散列表。

![image-20200521233946456](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200521233947.png)

![image-20200521233952641](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200521233954.png)

> **google 公司的一个上机题**

有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,名字,住址..),当输入该员工的 id 时, 要求查找到该员工的 所有信息.

> **要求:** 

- 1) 不使用数据库,,速度越快越好=>哈希表(散列) 
- 2) 添加时，保证按照 id 从低到高插入 [课后思考：如果 id 不是从低到高插入，但要求各条链表仍是从低到 高，怎么解决?] 
- 3) 使用链表来实现哈希表, 该链表不带表头[即: 链表的第一个结点就存放雇员信息] 
- 4) 思路分析并画出示意图

![image-20200521234103151](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200521234104.png)



## 树

> **二叉树**

**为什么需要树这种数据结构**

- 1) 数组存储方式的分析
  优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。 缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低 [示意图]
  画出操作示意图：

![image-20200525180116598](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200525180123.png)

- 2) 链式存储方式的分析 优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。 缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 【示意图】
  操作示意图：![image-20200525180154430](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200525180154.png)

- 3) 树存储方式的分析 能提高数据存储，读取的效率, 比如利用 二叉排序树(BinarySortTree)，既可以保证数据的检索速度，同时也 可以保证数据的插入，删除，修改的速度。【示意图,后面详讲】 案例:[7,3,10,1,5,9,12]

![image-20200525180209546](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200525180209.png)

 **树示意图**

![image-20200525180222179](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200525180222.png)

> **树的常用术语(结合示意图理解):**

- 1) 节点 
- 2) 根节点 
- 3) 父节点 
- 4) 子节点 
- 5) 叶子节点 (没有子节点的节点) 
- 6) 节点的权(节点值) 
- 7) 路径(从 root 节点找到该节点的路线) 
- 8) 层 
- 9) 子树 
- 10) 树的高度(最大层数) 
- 11) 森林 :多颗子树构成森林

> **二叉树的概念**

- 1) 树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。 

- 2) 二叉树的子节点分为左节点和右节点 

- 3) 示意图

  ![image-20200525180323762](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200525180323.png)

- 4) 如果该二叉树的所有叶子节点都在最后一层，并且结点总数=2^n-1,n 为层数，则我们称为满二叉树。

  ![image-20200525180331181](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200525180331.png)

- 5) 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二
  层的叶子节点在右边连续，我们称为完全二叉树

  ![image-20200525180342799](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200525180342.png)

> **二叉树遍历的说明** 

- 1) 前序遍历: 先输出父节点，再遍历左子树和右子树 
- 2) 中序遍历: 先遍历左子树，再输出父节点，再遍历右子树
- 3) 后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点 
- 4) 小结: 看输出父节点的顺序，就确定是前序，中序还是后序 

 **二叉树遍历应用实例(前序,中序,后序)**

![image-20200525180425948](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200525180426.png)

> **二叉树-查找指定节点**

- 1) 请编写前序查找，中序查找和后序查找的方法。
- 2) 并分别使用三种查找方式，查找 heroNO=5 的节点 
- 3) 并分析各种查找方式，分别比较了多少次 
- 4) 思路分析图解

![image-20200525180448609](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200525180448.png)

> **二叉树-删除节点**

- 1) 如果删除的节点是叶子节点，则删除该节点 
- 2) 如果删除的节点是非叶子节点，则删除该子树.
- 3) 测试，删除掉 5 号叶子节点 和 3 号子树. 
- 4) 完成删除思路分析

![image-20200525180530178](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200525180530.png)

**顺序存储二叉树**

基本说明

从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，
看右面的示意图

![image-20200525220602599](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200525220602.png)

> **要求:** 

1) 右图的二叉树的结点，要求以数组的方式来存放 arr:[1,2,3,4,5,6,6] 2) 要求在遍历数组 arr 时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历

> **顺序存储二叉树的特点:**

- 1) 顺序二叉树通常只考虑完全二叉树 
- 2) 第 n 个元素的左子节点为 2*n+1 *
- *3) 第 n 个元素的右子节点为 2*n+2 
- 4) 第 n 个元素的父节点为 (n-1)/2 
- 5) n: 表示二叉树中的第几个元素(按 0 开始编号如图所示)

需求: 给你一个数组 {1,2,3,4,5,6,7}，要求以二叉树前序遍历的方式进行遍历。 前序遍历的结果应当为 1,2,4,5,3,6,7 

**线索化二叉树** 

先看一个问题 将数列 {1,3,6,8,10,14 } 构建成一颗二叉树. n+1=7

![image-20200525220914109](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200525220914.png)

问题分析: 

- 1) 当我们对上面的二叉树进行中序遍历时，数列为 {8,3,10,1,6,14} 
- 2) 但是 6,8,10,14 这几个节点的 左右指针，并没有完全的利用上. 
- 3) 如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办? 
- 4) 解决方案-线索二叉树

> **线索二叉树基本介绍**

- 1) n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向 该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为"线索"）
- 2) 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(ThreadedBinaryTree)。根据线索性质
  的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种
- 3) 一个结点的前一个结点，称为前驱结点 4) 一个结点的后一个结点，称为后继结点

**线索二叉树应用案例**

应用案例说明：<!--将下面的二叉树-->，进行中序线索二叉树。中序遍历的数列为 {8,3,10,1,14,6}

![image-20200525220941965](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200525220942.png)

思路分析: 中序遍历的结果：{8,3,10,1,14,6}

![image-20200525220958712](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200525220958.png)

> **说明: 当线索化二叉树后，Node 节点的 属性 left 和 right ，有如下情况:** 

- 1) left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的 就是前驱节点. 
- 2) right 指向的是右子树，也可能是指向后继节点，比如 ① 节点 right 指向的是右子树，而⑩ 节点的 right 指向 的是后继节点.

**赫夫曼树** 

> **基本介绍**

- 1) 给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为 最优二叉树，也称为哈夫曼树(HuffmanTree), 还有的书翻译为霍夫曼树。 
- 2) 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近

> **赫夫曼树几个重要概念和举例说明**

- 1) 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为 1，则从根结点到第 L 层结点的路径长度为 L-1 
- 2) 结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结
  点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积 
- 3) 树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为 WPL(weighted path length),权值越大的结点离根结点越近的二叉树才是最优二叉树。 
- 4) WPL 最小的就是赫夫曼树

![image-20200526203652823](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200526203653.png)

> **赫夫曼树创建思路图解**

给你一个数列 {13,7,8,3,29,6,1}，要求转成一颗赫夫曼树.

构成赫夫曼树的步骤： 

- 1) 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树 
- 2) 取出根节点权值最小的两颗二叉树 
- 3) 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
- 4) 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数
  据都被处理，就得到一颗赫夫曼树 
- 5) 图解:

![image-20200526203729821](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200526203729.png)

**二叉排序树** 

> **基本介绍**

二叉排序树：BST:(BinarySort(Search)Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当
前节点的值小，右子节点的值比当前节点的值大。

特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点

比如针对前面的数据 (7,3,10,12,5,1,9) ，对应的二叉排序树为：

![image-20200527144334071](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200527144341.png)

>  **二叉排序树创建和遍历** 

一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树，比如: 数组为 Array(7,3,10,12,5,1,9) ， 创 建成对应的二叉排序树为 :

> **二叉排序树的删除**

二叉排序树的删除情况比较复杂，有下面三种情况需要考虑 

- 1) 删除叶子节点 (比如：2,5,9,12) 
- 2) 删除只有一颗子树的节点 (比如：1) 
- 3) 删除有两颗子树的节点.(比如：7,3，10) 
- 4) 操作的思路分析

**对删除结点的各种情况的思路分析:**

- 第一种情况: 删除叶子节点 (比如：2,5,9,12)

  - 思路
    -  (1) 需求先去找到要删除的结点 targetNode 
    -  (2) 找到 targetNode 的 父结点 parent 
    -  (3) 确定 targetNode 是 parent 的左子结点 还是右子结点 
    -  (4) 根据前面的情况来对应删除 左子结点 parent.left=null 右子结点 parent.right=null; 

- 第二种情况: 删除只有一颗子树的节点 比如 1

  - 思路 

    - (1) 需求先去找到要删除的结点 targetNode 

    - (2) 找到 targetNode 的 父结点 parent 

    - (3) 确定 targetNode 的子结点是左子结点还是右子结点 

    - (4)targetNode 是 parent 的左子结点还是右子结点 

    - (5) 如果 targetNode 有左子结点 

      - 5.1 如果 targetNode 是 parent 的左子结点parent.left=targetNode.left; 
      - 5.2 如果 targetNode 是 parent 的右子结点 parent.right=targetNode.left; 

    - (6) 如果 targetNode 有右子结点 

      - 6.1 如果 targetNode 是 parent 的左子结点 parent.left=targetNode.right; 

      - 6.2 如果 targetNode 是 parent 的右子结点 parent.right=targetNode.right

- 情况三 ： 删除有两颗子树的节点.(比如：7,3，10)

  - 思路 
    - (1) 需求先去找到要删除的结点 targetNode 
    - (2) 找到 targetNode 的 父结点 parent 
    - (3) 从 targetNode 的右子树找到最小的结点 
    - (4) 用一个临时变量，将 最小结点的值保存 temp=11 
    - (5) 删除该最小结点 
    - (6) targetNode.value=temp



**平衡二叉树(AVL 树)** 

> **看一个案例(说明二叉排序树可能的问题)** 

给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在. 

左边 BST 存在的问题分析:

- 1) 左子树全部为空，从形式上看，更像一个单链表. 
- 2) 插入速度没有影响 
- 3) 查询速度明显降低(因为需要依次比较), 不能发挥 BST的优势，因为每次还需要比较左子树，其查询速度比
  单链表还慢 
- 4) 解决方案-平衡二叉树(AVL)

> **基本介绍**

- 1) 平衡二叉树也叫平衡二叉搜索树（Self-balancingbinarysearchtree）又被称为 AVL 树， 可以保证查询效率较高。 
- 2) 具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵 平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 
- 3) 举例说明, 看看下面哪些 AVL 树, 为什么?

![image-20200527170531377](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200527170531.png)

 **应用案例-单旋转(左旋转)**

- 1) 要求: 给你一个数列，创建出对应的平衡二叉树.数列 {4,3,6,5,7,8} 
- 2) 思路分析(示意图)

![image-20200527170602376](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200527170602.png)

**应用案例-单旋转(右旋转)**

- 1) 要求: 给你一个数列，创建出对应的平衡二叉树.数列 {10,12,8,9,7,6} 
- 2) 思路分析(示意图)

![image-20200527170644950](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200527170645.png)

**应用案例-双旋转**

前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下，单旋转不能完成平衡二叉树的转换。比如数列 int[]arr={10,11,7,6,8,9}; 运行原来的代码可以看到，并没有转成 AVL 树. int[]arr={2,1,6,5,7,3};// 运行原来的代码可以看到，并没有转成 AVL 树 

- 1) 问题分析

![image-20200527170710614](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200527170710.png)

- 2) 解决思路分析 

1. 当符号右旋转的条件时 
2. 如果它的左子树的右子树高度大于它的左子树的高度
3. 先对当前这个结点的左节点进行左旋转 
4. 在对当前结点进行右旋转的操作即可 

## 多叉树

二叉树的问题分析 二叉树的操作效率较高，但是也存在问题, 请看下面的二叉树

![image-20200527175713420](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200527175713.png)

- 1) 二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如 1 亿)， 就 存在如下问题: 
- 2) 问题 1：在构建二叉树时，需要多次进行 i/o 操作(海量数据存在数据库或文件中)，节点海量，构建二叉树时，
  速度有影响 
- 3) 问题 2：节点海量，也会造成二叉树的高度很大，会降低操作速度

**多叉树**

- 1) 在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点， 就是多叉树（multiwaytree） 
- 2) 后面我们讲解的 2-3 树，2-3-4 树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。 
- 3) 举例说明(下面 2-3 树就是一颗多叉树)

![image-20200527182843317](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200527182843.png)

> **B 树的基本介绍** 

B 树通过重新组织节点，降低树的高度，并且减少 i/o 读写次数来提升效率。

![image-20200527182858374](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200527182858.png)

- 1) 如图 B 树通过重新组织节点， 降低了树的高度. 
- 2) 文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)， 这样每个节点只需要一次 I/O 就可以完全载入 
- 3) 将树的度 M 设置为 1024，在 600 亿个元素中最多只需要 4 次 I/O 操作就可以读取到想要的元素,B 树(B+)广泛
  应用于文件存储系统以及数据库系统中

>  **2-3 树**

 2-3 树是最简单的 B 树结构, 具有如下特点

- 1) 2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件) 
- 2) 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.
- 3) 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点. 
- 4) 2-3 树是由二节点和三节点构成的树。 

> **2-3 树应用案例** 

将数列{16,24, 12,32,14, 26,34,10, 8,28,38,20} 构建成 2-3 树，并保证数据插入的大小顺序。(演示一下构建 2-3 树的过程.)

![image-20200527183010147](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200527183010.png)

**插入规则:** 

- 1) 2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件) 
- 2) 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.
- 3) 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点 
- 4) 当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层， 拆后仍然需要满足上面 3 个条件。 
- 5) 对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则

**其它说明** 

除了 23 树，还有 234 树等，概念和 23 树类似，也是一种 B 树。 如图:

![image-20200527183053493](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200527183053.png)

> **B 树的介绍** 

B-tree 树即 B 树，B 即 Balanced，平衡的意思。有人把 B-tree 翻译成 B-树，容易让人产生误解。会以为 B-树 是一种树，而 B 树又是另一种树。实际上，B-tree 就是指的 B 树。 

前面已经介绍了 2-3 树和 2-3-4 树，他们就是 B 树(英语：B-tree 也写成 B-树)，这里我们再做一个说明，我们在学 习 Mysql 时，经常听到说某种类型的索引是基于 B 树或者 B+树的，如图:

![image-20200527183128881](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200527183128.png)

对上图的说明: 

- 1) B 树的阶：节点的最多子节点个数。比如 2-3 树的阶是 3，2-3-4 树的阶是 4
- 2) B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询
  关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点
- 3) 关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据. 
- 4) 搜索有可能在非叶子结点结束 
- 5) 其搜索性能等价于在关键字全集内做一次二分查找

> **B+树的介绍**

B+树是 B 树的变体，也是一种多路搜索树。

![image-20200527183212699](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200527183212.png)

对上图的说明: 

- 1) B+树的搜索与 B 树也基本相同，区别是 B+树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性
  能也等价于在关键字全集做一次二分查找 
- 2) 所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)
  恰好是有序的。 
- 3) 不可能在非叶子结点命中 
- 4) 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层
- 5) 更适合文件索引系统 
- 6) B 树和 B+树各有自己的应用场景，不能说 B+树完全比 B 树好，反之亦然.

**B*树的介绍** 

B*树是 B+树的变体，在 B+树的**非根和非叶子**结点再增加指向兄弟的指针。

![image-20200527183259794](https://guliedu-zhanbo.oss-cn-beijing.aliyuncs.com/blog/image/20200527183259.png)

B*树的说明: 

- 1) B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为 2/3，而 B+树的块的最低使用率为的 1/2。 
- 2) 从第 1 个特点我们可以看出，B*树分配新结点的概率比 B+树要低，空间使用率更高

